# 标签组功能修复详细实现计划

## 1. 修复 getTagsByTagGroupId 方法
**问题**：该方法返回空列表，导致编辑标签组页面中已添加的标签没有保持勾选状态
**实现步骤**：
- 完善 `getTagsByTagGroupId` 方法，从标签文件管理器获取所有标签
- 根据标签组数据中的 tagIds 过滤出对应的标签实体
- 返回完整的 TagEntity 列表

**关键代码修改**：
```kotlin
// 在 TagViewModelNew.kt 中
suspend fun getTagsByTagGroupId(tagGroupId: Long): List<com.example.yumoflatimagemanager.data.local.TagEntity> {
    return try {
        val tagGroupData = TagGroupFileManager.readTagGroup(tagGroupId)
        if (tagGroupData == null) {
            return emptyList()
        }
        
        // 从标签文件管理器获取所有标签
        val allTags = TagFileManager.getAllTags()
        
        // 根据 tagIds 过滤并转换为 TagEntity
        return allTags
            .filter { tagGroupData.tagIds.contains(it.id) }
            .map { it.toTagEntity() }
    } catch (e: Exception) {
        e.printStackTrace()
        println("ERROR: 获取标签组下的标签失败 - 标签组ID: $tagGroupId, 错误: ${e.message}")
        emptyList()
    }
}
```

## 2. 添加"未分组"标签组
**问题**：缺少默认的"未分组"标签组
**实现步骤**：
- 在 `TagGroupFileManager` 中添加初始化逻辑
- 创建默认的"未分组"标签组，id=1
- 设置 `isDefault=true`，确保双击时不允许编辑
- 确保应用启动时自动创建

**关键代码修改**：
```kotlin
// 在 TagGroupFileManager.kt 中
init {
    // 确保标签组目录存在
    createTagGroupsDirectory()
    
    // 初始化默认的"未分组"标签组
    initializeDefaultTagGroup()
}

/**
 * 初始化默认的"未分组"标签组
 */
fun initializeDefaultTagGroup() {
    // 检查是否已存在"未分组"标签组
    val allGroups = getAllTagGroups()
    if (allGroups.none { it.name == "未分组" || it.isDefault }) {
        val defaultGroup = TagGroupData(
            id = 1,
            name = "未分组",
            sortOrder = 0,
            isDefault = true,
            tagIds = emptyList()
        )
        writeTagGroup(defaultGroup)
    }
}
```

## 3. 实现标签组选择的持久化
**问题**：刚进入软件时没有持久化当前的标签组选择
**实现步骤**：
1. **修改 ConfigManager.kt**：
   - 添加标签组选择的配置项
   - 实现读写方法

2. **修改 TagConfig.kt**：
   - 添加 `selectedTagGroupId` 字段

3. **修改 TagPersistenceManager.kt**：
   - 添加保存和恢复标签组选择的方法

4. **修改 TagViewModelNew.kt**：
   - 在标签组选择变化时保存到配置
   - 在应用启动时恢复标签组选择

**关键代码修改**：
```kotlin
// 在 TagConfig.kt 中
data class TagConfig(
    // 现有字段...
    val selectedTagGroupId: Long = 1L // 默认选中"未分组"标签组
)

// 在 TagPersistenceManager.kt 中
fun saveTagGroupSelection() {
    val config = ConfigManager.readTagConfig()
    val newConfig = config.copy(selectedTagGroupId = tagState.selectedTagGroupId ?: 1L)
    ConfigManager.writeTagConfig(newConfig)
}

fun restoreTagGroupSelection() {
    val config = ConfigManager.readTagConfig()
    tagState.selectTagGroup(config.selectedTagGroupId)
}

// 在 TagViewModelNew.kt 中
fun selectTagGroup(groupId: Long) {
    tagState.selectTagGroup(groupId)
    // 保存到配置
    persistenceManager.saveTagGroupSelection()
}
```

## 4. 修复标签组过滤功能
**问题**：选中标签组后标签过滤没有反应
**实现步骤**：
- 检查标签组选择后的逻辑处理
- 确保标签过滤逻辑正确使用标签组信息
- 完善标签组与标签的关联管理

## 5. 确保"未分组"标签组和普通组区分开
**问题**："未分组"标签组需要与普通组区分
**实现步骤**：
- 利用现有的 `isDefault` 字段进行区分
- 双击事件处理中已存在检查 `isDefault` 的逻辑，确保默认组不可编辑
- 在 UI 上显示视觉区分（如特殊样式或图标）

**关键代码修改**：
```kotlin
// 在 TagGroupItem.kt 中（如果存在）
// 添加默认标签组的特殊样式
if (tagGroup.isDefault) {
    // 默认标签组的特殊样式
    modifier = modifier.background(MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.5f))
    // 可以添加其他视觉区分，如特殊图标
}
```

## 6. 测试和验证
**实现步骤**：
- 运行应用测试标签组功能
- 验证编辑标签组页面已添加标签保持勾选状态
- 验证选中标签组后标签过滤功能正常
- 验证应用启动时标签组选择已持久化
- 验证"未分组"标签组存在且不可编辑
- 验证"未分组"标签组与普通组有视觉区分

## 实现顺序
1. 修复 `getTagsByTagGroupId` 方法
2. 添加"未分组"标签组初始化逻辑
3. 修改 TagConfig.kt 添加 selectedTagGroupId 字段
4. 修改 ConfigManager.kt 支持标签组选择配置
5. 修改 TagPersistenceManager.kt 实现标签组选择的持久化
6. 修改 TagViewModelNew.kt 保存和恢复标签组选择
7. 测试所有功能

## 关键文件修改
- `TagViewModelNew.kt`: 完善标签组相关方法
- `TagGroupFileManager.kt`: 添加默认标签组初始化
- `TagConfig.kt`: 添加标签组选择配置项
- `ConfigManager.kt`: 支持标签组选择配置
- `TagPersistenceManager.kt`: 实现标签组选择的持久化
- `TagState.kt`: 保存当前选中的标签组ID

## 预期效果
1. 编辑标签组页面中，已添加的标签将保持勾选状态
2. 选中标签组后，标签过滤功能正常工作
3. 应用重启后，之前选中的标签组将被恢复
4. "未分组"标签组自动创建，不可编辑，与普通组有区分
5. 所有标签组数据正确存储在外部公共文件夹中