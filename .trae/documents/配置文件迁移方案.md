# 配置文件迁移方案

## 一、迁移目标
将所有应用相关配置从SharedPreferences迁移到固定的公共目录`/storage/emulated/0/YuMoBox/config/`下，并按配置类型分别存储在独立的配置文件中。

## 二、新配置文件结构
```
/storage/emulated/0/YuMoBox/
├── config/
│   ├── security.json       # 安全模式设置
│   ├── album.json          # 相册配置（排序、网格列数等）
│   ├── tag.json            # 图片标签配置
│   └── watermark.json      # 水印显示选项
```

## 三、迁移步骤

### 1. 初始化配置目录
- 使用FileOperator库创建`/storage/emulated/0/YuMoBox/config`目录
- 确保目录具有正确的读写权限

### 2. 迁移现有配置
- 从SharedPreferences读取所有配置
- 按类型分类并写入到对应的JSON文件中
- 迁移完成后验证数据完整性

### 3. 修改配置读写逻辑
- 替换PreferencesManager中的SharedPreferences实现
- 使用FileOperator库进行文件读写操作
- 实现配置的缓存机制以提高性能

## 四、具体实现

### 1. 创建配置管理类
- 新建`ConfigManager`类，负责统一管理所有配置文件
- 实现配置的读取、写入、迁移等核心功能

### 2. 实现配置目录初始化
```kotlin
// 获取配置存储根目录
fun getConfigRootDirectory(): File {
    return File(Environment.getExternalStorageDirectory(), "YuMoBox/config")
}

// 创建配置目录
fun createConfigDirectory() {
    val configDir = getConfigRootDirectory()
    if (!configDir.exists()) {
        configDir.mkdirs()
    }
}
```

### 3. 实现配置迁移逻辑
```kotlin
// 从SharedPreferences迁移到文件存储
fun migrateConfig(context: Context) {
    // 1. 检查是否已迁移
    if (isConfigMigrated()) return
    
    // 2. 创建配置目录
    createConfigDirectory()
    
    // 3. 读取现有配置
    val preferences = context.getSharedPreferences("YuMoFlatImageManagerPreferences", Context.MODE_PRIVATE)
    
    // 4. 迁移安全模式配置
    migrateSecurityConfig(preferences)
    
    // 5. 迁移相册配置
    migrateAlbumConfig(preferences)
    
    // 6. 迁移标签配置
    migrateTagConfig(preferences)
    
    // 7. 迁移水印配置
    migrateWatermarkConfig(preferences)
    
    // 8. 标记迁移完成
    markConfigMigrated()
}
```

### 4. 实现配置读写接口

#### 读取配置函数
```kotlin
// 读取配置
fun <T> readConfig(fileName: String, clazz: Class<T>): T? {
    val configFile = getConfigFile(fileName)
    if (!configFile.exists()) return null
    
    val jsonString = FileOperator.readFileText(configFile.absolutePath)
    return Gson().fromJson(jsonString, clazz)
}
```

#### 写入配置函数
```kotlin
// 写入配置
fun <T> writeConfig(fileName: String, config: T) {
    val configFile = getConfigFile(fileName)
    val jsonString = Gson().toJson(config)
    FileOperator.write2File(jsonString.toByteArray(), configFile)
}
```

**函数解释**：
- 这是一个泛型函数，可以处理任何类型的配置对象
- 参数`fileName`指定要写入的配置文件名（如"security.json"）
- 参数`config`是要写入的配置对象
- 函数首先获取配置文件对象，然后使用Gson将配置对象序列化为JSON字符串，最后使用FileOperator库将JSON字符串写入文件

**使用示例**：

1. **保存安全模式配置**
```kotlin
// 安全模式配置数据类
data class SecurityConfig(
    val isSecureModeEnabled: Boolean = false,
    val privateAlbumIds: List<String> = emptyList()
)

// 创建安全模式配置对象
val securityConfig = SecurityConfig(
    isSecureModeEnabled = true,
    privateAlbumIds = listOf("album1", "album2")
)

// 写入配置到security.json文件
ConfigManager.writeConfig("security.json", securityConfig)
```

2. **保存相册网格列数配置**
```kotlin
// 相册配置数据类
data class AlbumConfig(
    val gridColumns: MutableMap<String, Int> = mutableMapOf(),
    val sortConfigs: MutableMap<String, SortConfig> = mutableMapOf()
)

// 创建相册配置对象
val albumConfig = AlbumConfig()
albumConfig.gridColumns["album1"] = 4
albumConfig.gridColumns["album2"] = 3

// 写入配置到album.json文件
ConfigManager.writeConfig("album.json", albumConfig)
```

3. **保存标签配置**
```kotlin
// 标签配置数据类
data class TagConfig(
    val expandedTagIds: Set<Long> = emptySet(),
    val activeTagFilterIds: Set<Long> = emptySet(),
    val excludedTagIds: Set<Long> = emptySet()
)

// 创建标签配置对象
val tagConfig = TagConfig(
    expandedTagIds = setOf(1L, 2L, 3L),
    activeTagFilterIds = setOf(1L, 3L)
)

// 写入配置到tag.json文件
ConfigManager.writeConfig("tag.json", tagConfig)
```

### 5. 修改现有代码
- 将所有使用PreferencesManager的地方替换为ConfigManager
- 更新相关的配置读写逻辑
- 确保应用启动时自动执行配置迁移

## 五、验证步骤
1. 运行应用，自动执行配置迁移
2. 检查`/storage/emulated/0/YuMoBox/config/`目录下是否生成了所有配置文件
3. 验证配置文件内容是否完整准确
4. 测试配置修改功能是否正常工作
5. 重启应用，验证配置是否能正确加载

## 六、技术要点
- 使用FileOperator库处理文件操作
- 使用Gson进行JSON序列化和反序列化
- 实现配置的缓存机制以提高性能
- 确保配置文件的安全性和完整性
- 处理配置文件不存在或损坏的情况

## 七、文件列表
- `ConfigManager.kt`：核心配置管理类
- `ConfigMigration.kt`：配置迁移逻辑
- `ConfigModels.kt`：配置数据模型
- 修改所有使用PreferencesManager的相关文件

## 八、迁移时间
- 迁移过程预计在应用首次启动时完成，耗时约1-2秒
- 后续启动将直接使用新的配置文件，无需再次迁移

## 九、风险评估
1. **数据丢失风险**：迁移过程中进行数据备份，确保数据安全
2. **兼容性风险**：无需考虑与旧版应用的配置兼容性
3. **性能风险**：实现配置缓存机制，确保读写性能不受影响